[{"content":"图灵完备alpha篇攻略3 BYTE NAND 虽然但是，它好像写错了，标题写着nand门，也就是与非门，要求里也是写着与非门，但中文翻译处写着或门，按与非门来吧，也就是逐位处理，如下\nBYTE NOT 简单的不解释了\nADDING BYTES 8bit的加法，先按最低位使用加法，，如果有进位那就给下一位的提供进位信号，然后按对应的位输入对应的位置，实现如下\nMULTIPLEXER 同\n","date":"2025-03-03T15:32:57+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87alpha%E7%89%88%E6%94%BB%E7%95%A53/","title":"图灵完备alpha版攻略3"},{"content":"图灵完备alpha篇攻略2 ODD Number of Singals 这个要求是，单数个高电平的时候输出高电平，其他时候低电平，但是，现在已经有同或门了，如果两个数相同，就输出1，不同就输出0，那么，如果输出是1，必定是一个1和一个0的组合， 也就是必定是单数，但又有，两个单数加起来是双数，所以得排除两个都是单数或者两个都是双数的情况，总结而言，就是需要一个异或门，所以，输出示例如下：\nCIRCULAR DEPENDENCY 循环依赖，输出跟输入的一个脚不同即可，最好正负还会影响输出结果，如下\ncounting siginals 解法1 排除法 是一个数高电平数的一个元件，输入需要按4，2，1排列，那么首先可以确定，如果四个全部亮起时，4的开关得亮起\n其中第二好确认的是另一个0的位置，其中解法就在上面单双数那，因为单双数就是影响的第一位的数值，\n2位处最复杂，如果按照正向去找会比较麻烦，亮起时包含条件2、3，此时采用反向讨论，也就是说，我们需要排除以下几种情况，0，1，4，这样会比较方便一些，\n0 其实就是四个or门不满足的情况，突变点时四个输入都为0，但目前还无法搭建4or门，结构即是两个or门分别连着四路输出，然后这两个or门的输出为第三个or门的输入，此时最后如果最后一个门是or的话输出会导致突变点正常$（0,0,0,0）$，但输出相反，所以需要输出接着not，就是nor门，所以结构如下图标0处\n1 这里有四种情况，也就是亮的4路选一路，然后其他三路全部为0，全部为0的突变点在(0,0,0)，对应3or门，但是输出需要取反，然后这个结果需要同时满足最后一路是1，此时and门的逻辑作用就体现了，需要两个条件同时满足，即(A\u0026amp;B)，做法只需要把多个条件全部接入and门即可，以及，四种情况只要满足1个条件即可，所以满足条件的3个0、1个1的四种情况用三个or门连接起来即可\n那么，要2，3的情况亮起，我需要$0,1,4$三种情况都不满足时亮起，也就是突变点对应的$(0,0,0)$,也就是说，我需要使用3or门取反即可实现\n解法2 暴力解法 参考解法1，0，4不动，主要看中间第三路，三路参考1路解法，即调换3or门处类似换成3and门即可，正负有小的变化，但2的情况有所复杂化，按1的值来取，有 $(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)$六种可能性，其中其余全是0，也就是启用nor即可，因为是6种条件随便满足一种即可，所以3*2的or门即可\nHALF ADDER 很明确，只要两个门分开处理就行，刚好能对应上异或门和与门，解法如上\nDELAYED LINES 过于简单的我就不解说了，延迟两刻输出\nDOUBLE THE NUMBER 把数值放大两倍后输出，其实实际上就是左移数字，毕竟\n$$假定输入数是a,a=(a_7\\cdot2^7+...+a_0\\cdot2^0),则2a=(a_7\\cdot2^8+...+a_0\\cdot2^1+0\\cdot2^0)$$$$a = \\sum_{0}^{7} {a_i\\cdot2^i},2a=2\\cdot\\sum_{0}^{7} {a_i\\cdot2^i}=\\sum_{1}^{8} {a_i\\cdot2^i}+0\\cdot2^0$$其中$2^8$部分因为进位可以直接舍去了，如果在8bit数据中，存在$2^8$就是已经溢出了，易见a_0的数值，也就是第一位被填到了第二位，以此类推，全部发生了移位操作，\nFULL ADDER 全加器，其中sum部分的很明显，只是一个观察单双数的位，另一位则是观察是否有两位以上的1，那么开工\n先用异或门判断两位是否相同，输出则是这两位是否是单数，如果是单数输出1，另一位也是1的话，那么输出2，不是单数，则需要输出0，也就是后面的算法依旧也是判断单双数，都亮起或者灭了就是双，不同就是单数，实际就是一个异或门，所以，使用两个异或门即可完成任务，参考如解法图 第二位进位car位，需要有两位及两位以上的1，2位，刚好and门要有1的输出必须要有两个1，那么，思路很明确了，只要对3个输入进行两两检测，有and门为1即可，也就是说，3个and门只要满足一个或者以上即可，所以可以对这三个and门的输出使用3or门 ODD TICKS 看到延迟输入，我的第一个想法就是，其他先不管，先想办法实现一下类似时钟的功能，通过or门，然后延迟输出它的相反数，这样就可以实现了，第一刻延迟线相反之后输出是1， 也就是说时钟第一刻输出就是1，然后延迟线存储上一位的1，第二刻时输出1的相反，也就是0，0or0输出0，然后，寄存器输出，为啥想到or呢，因为这时候还没有开关，图灵完备不允许0和1一起输出， 属于游戏特性，那么可以用这个数和0经过or门来实现，但第一刻是1，不是0，每个都相反了，那么只要取一次反即可\nBIT INVERTER 不解释，对比信号输出即可\nBIG SWITCH 只允许使用两个开关和两个非门来完成这个关卡，无疑思路就是，两路数据，开关必须得都处于不同状态，同时开启会导致图灵完备游戏报错，怎么控制呢？思路也很明了了，有个非门在提示着， 也就是说，可以用一个输入作为信号控制开关，如果输入是1开一路，输入时2开另一路，那么另一个输入也如此了，也就是通过not来控制本信号位的通断，\n先从这一位信号控制的地方下手\n如果信号位直接控制的一路，现在这个控制位信号是1，那么如果这开关的输入位是1的话，根据对照表，输出就得是0，此时控制位已经没法动了，所以只能是输入位接上not，此时消耗一个not\n又有控制位信号是0的话，控制取反信号一路的开，如果这一路输入也是0的话，得输出0，刚好不用取反，输入是1的话也导通\n那么，就有\n","date":"2025-03-02T14:36:14+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87alpha%E7%89%88%E6%94%BB%E7%95%A52/","title":"图灵完备alpha版攻略2"},{"content":"教程 安装node.js 官网链接node.js 下一步下一步安装完毕之后在cmd环境下测试一下以下命令，如果下面没有where npm添加环境变量，具体来说是在你安装nodejs文件夹下找到npm之后，添加npm所在的目录进环境变量即可， 例如这是我的安装路径，那么就把这E:\\Program Files\\nodejs\\一段新增入环境变量\nE:\\Program Files\\nodejs\\npm E:\\Program Files\\nodejs\\npm.cmd where npm npm install axios 其中检查第一步的输出，是否有包含一个空的npm的文件，在system32目录下，而且在如果有就去对应目录给删了。\n因为环境变量的执行优先级，system32文件夹处在一个很高的优先级上， 会导致你在命令行输入npm时，系统在环境变量内从前往后查找名为npm的文件或者支持直接执行的文件， 因为一般新增环境变量通常都是补在末尾，也就是说，system32这样的系统文件一般会获得极高的优先级，然后下面又有空的那个npm文件，就会导致你使用npm命令时调用的就是system32下面的npm空文件， 导致了你的文件不可用，但是处于system32文件夹下的npm，好像没有任何用处，删除即可 （谁家包管理器有事没事往system32里塞文件啊）\n安装yarn 安装 yarn\nnpm install -g yarn 安装koishi.msi文件 安装koishi.msi后，在目标目录下初始化koishi,使用以下命令\nnpm init koishi@latest 第一次启动会直接启动本地服务端口，第二次启动需要cd koishi-app进入文件夹后执行npm run dev 然后执行\nyarn install 该命令会自动调用同目录下的package.json文件执行安装koishi的依赖\n添加插件 步骤一 下载好phi-plugin-koishi之后,确保src文件上一级有额外的文件夹，比如说记录你的父级文件夹为phi-plugin，则确保目录为/phi-plugin/src这样的目录结构就行\n步骤二 因为koishi并不会给你拖入的文件夹主动添加工作环境内，所以有两种可选的方式来初始化\n新建插件方案 yarn setup phi-plugin 它会在/koishi-app/目录下新建一个external文件夹,然后创建/phi-plugin/src/index.ts这样的文件结构，此时你可以直接删除phi-plugin文件夹然后拖动上面步骤一同名的phi-plugin文件夹过来，就可以正常被读取了\n修改koishi.yml方案 直接在/koishi-app/目录下新建external文件夹，新建插件方案的文件夹是因为yarn setup phi-plugin命令新建的，这里我们自己新建一个文件夹，然后拖动步骤一中的phi-plugin文件夹进来， 再去/koishi-app/koishi.yml文件内追加以下内容:\nphi-plugin: {} 其中对齐plugin下一级即可，如下图,其中不必在意gkna40编号，添加上面的即可，npm run dev后会自动添加\n构建源代码 yarn build\n随后参考官网即可https://koishi.js.org\n","date":"2025-03-01T10:55:46+08:00","image":"https://adeepblue.github.io/p/phi-plugin-koishi%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%B0%E5%BD%95/phi-plugin-logo_hu_97e3d378a996e59c.png","permalink":"https://adeepblue.github.io/p/phi-plugin-koishi%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%B0%E5%BD%95/","title":"Phi Plugin Koishi初始化记录"},{"content":"一些关于游戏的说明 图灵完备更新了版本，疑似修复了我图灵完备攻略6的bug，但是以前的存档不能用了（可能类似于内部数据结构变动），也正好，我打算借着这个机会重新玩一下以前的关卡，有一些在现在的视角有更优雅更好的解法， 就当是补以前没写博客时的攻略了,虽然躲不掉bug也挺难受的\n前置的一些逻辑说明 AND门和OR门，一定程度可以理解为统合一些条件的检查，比如说我有条件1，条件2，条件3全部满足的情况，可以理解为编程中的if，那么也就是说三个条件都要满足才会让输出变成高电平， 也就是 (condition1)\u0026amp;\u0026amp;(condition2)\u0026amp;\u0026amp;(condition3),or门同理，(condition1)||(condition2)||(condition3)，这点在以后的分类讨论中会很有用， 比如满足需要输出的条件1，条件2，条件3，然后所有需要输出的条件状态下，用or连接即可，表示只要有一个条件满足了就允许输出高电平\n图灵完备alpha篇攻略1 NAND门 (NAND GATE) 点击输入观察输出，改成对应的类型即可，最终结果是，除了输入1和2都是高电平的时候低电平输出\nNOT GATE 现在我们手里的只有一个NAND门，但是，由于nand门的特性，我们只要把nand的两个输入绑定成一样即可，4个不同的输入就会坍缩成2输入，也就是0和1\nAND GATE 观察NAND门，它信号也只有两个输入都是1的时候才会为0，这是一个特殊的突变点，and门也有类似的结构，但是突变点在两个输入都是1的时候，结果为1，那么， 现在已经有not门可以取反了，我就可以用not门直接反转输出结果，在nand的末尾加上not门就是and门了\nNOR GATE 或非门\n我们所使用的只有两个元件，一个nand，一个not，其中抓住突变点，两个低电平输入时,突变为高电平，那么，我直接选择反转两个输入电平，使用非门就可以了，这样突变发生在（0，0）处， 但是，这样更改后的nand门的输出跟预期输出完全相反，那么我们只需要反转一下输出，给输出加一个非门即可\nOR GATE 或门，上面或非门不安非门即可，不上图了\nALWAYS ON SECOND TICK 小技巧嘛，咋说呢，现在已经有and门了，and是严格限制输入的，必须两个都是正才提供输出，跟题目预期吻合，那么只要修改输入端就可以了，也就是确定了输入+not门得得到正正（输入了and才输出高电平） 那么，一个正一个负，很明显第二个需要not来反转信号\nXOR GATE 异或门\n异或门 仔细观察一下，我们也可以理解为，有两个突变点，一个是正正，一个是负负，其中or,and,nor,nand门的另一个作用是，可以统合两个输入的结果,其中or门，这个形状，其实中心反转一下， 稍微重合一下，就有点类似能得到图中的结果对吧，突变点是0，0而另一边突变点是1,1找到该元件nand，这样，一边已知的是or的1，1处的输出需要被nand覆盖，nand处0，0处的输出也需要被or覆盖 其中中间部分在or和nand下都是1，那很明显了，在最后两边结果出来的时候加一个and门统合一下两边的输出即可\nBIGGER OR GATE 因为比较简单我直接放结果图了\nBIGGER AND GATE XNOR GATE 反转XOR门即可\nDOUBLE TROUBLE 具体要求是，如果高电平数大于2就输出高电平，那么，我也可以理解为，对所有的输入进行一个and门操作，得到的结果有$3+2+1=6$种结果，这其中只要有一种是高电平， 就可以输出高电平了，这正好就是逻辑说明中or门,刚好又有3输入or门，将他们衔接起来，最后两个3or门用一个2输入or门再衔接（实际就是一个6输入or门的电路）\n下一篇攻略链接（更新后放入）\n","date":"2025-02-28T11:08:48+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87alpha%E7%89%88%E6%94%BB%E7%95%A51/","title":"图灵完备alpha版攻略1"},{"content":"图灵完备部分游戏攻略 函数 后面再更新了，目前觉得架构太差后面改了64位了再调了\n机器赛跑 有一说一，改动架构之前，我使用了通过最简陋的代码通过了，后续再改动吧\n我开始搭的64位计算机 虽然这并不是游戏内关卡，我也好几天没更新了，改架构，我想着嘛，要改就改64位的，方便以后加东西，于是就有了下面的一些\n看了一下指令集，好像8位就没再变化过了，那只能写在别处了，怪不方便的，以及是，介绍一下我现在的新的寻址方案，如下，利用判定寻址信号线的数据是否跟常数相等来决定这位是否要输出， 也就是换个说法就是，我可以通过这个常数决定它的地址位\n这是运算器的指令集，我打算直接前256位都用来放运算的，虽然不知道会不会够\n1 add 2 sub 3 times 4 div 5 or 6 nor 7 nand 8 and 9 xor 10 xnor 11 not 12 ashr 13 ror 14 rol 15 shr 16 shl eq表示equal，相等，ns表示no-sign，无符号状态，s表示sign，有符号的\n17 eq 18 lessns 19 lesseqns 20 greater_ns 21 greatereq_ns 22 less_s 23 lesseq_s 24 greater_s 25 greatereq_s 26 always 27 notime 38 noteq 这是指令前256位现已分配的，然后是256位之后的，我打算把第九第十位分配成参数1和参数2的立即数指令，这个必须独立在其他指令之外的，\n因为也玩到这了，看了一下别人的架构，有点羡慕，我好像有点思维定式了，其实pop push那些命令只指定少数的参数的，亦或者说是内存的读写，没必要输出4位空一位，以及，对上面的一些内容修改如下：\n栈前面忘记pop的时候弹出值了，重新修改了一下如上，因为第三位和第四位已经不需要再用了，也就是说，我可以临时修改步进值来节省程序位，现在直接写了一个可临时调整的步进器\n因为图灵完备游戏中没处列，我先把基础语法在这写一下然后在游戏中对照这个优化吧\n28-mov [reg|io] [reg|io](result) 29-jmp [label] default-add+[im|io] [reg|io] [reg|io] [result-reg](result) 30-pop [reg|io](result) 31-push+[im] [reg|num|io] 32-call [label] 33-ret 34-set [reg](result) [num] 35-write_ram+[index_or_not|0] [reg|io] #可以是0是默认写入1是加入索引,见36 36-write_ram+[index_or_not|1] [reg|io] [index] 37-get_ram [reg](index) [reg](result) default-not [reg] [reg] 38-noteq 读写地址 1-16 reg 17 count 18 io 其中逻辑代码和运算代码已经占用了27位，以及是第九位，第十位，也就是256和512位分别对应是立即数模式\n之前一直不知道内存这四个输入干什么用的，直到测试了64位的，刚刚我一脸懵，为啥64位+256一下子就没了，直到意识到，刚好四倍，以及是其他口输入跳到右上画框的地方去了， 哦，我就懂了，也就是说，数据位宽4倍的状态下，4位可以同时写入，并且这是一个字节，算是意外收获吧\n最后修了几个小bug\n因为noteq忘了现在在上面作为第38位补上\n20250226更新\n更新一下我的计算机架构\n因为get_ram的读写问题，我准备把指令划区了，目前打算1-64划给add等计算指令，填不满的空着，以及64到128的给逻辑指令，129后面则是其他，例如内存的读写指令 即get_ram以及其他指令等，以下介绍各种模块\ncalc 计算模块 语法\nexcept not [command]|[command+im] [reg] [reg] [reg](result) not not|not+im [reg] [reg] 机器码指令对照表\n1 add 2 sub 3 times 4 div 5 or 6 nor 7 nand 8 and 9 xor 10 xnor 11 ashr 12 ror 13 rol 14 shr 15 shl 63 not 特意把not放到末尾是因为它只要占用3个程序位即可,其他在process-center可以一起包起来，因为语法都是一样的\nlogic 逻辑模块 语法\n[command]|[command+im] [reg] [reg] [num](count) 机器码指令对照表\n64 eq 65 noteq 66 lessns 67 lesseqns 68 greater_ns 69 greatereq_ns 70 less_s 71 lesseq_s 72 greater_s 73 greatereq_s 其他指令及其语法 128-mov [reg|io] [reg|io](result) 129-jmp [label] default-add+[im|io] [reg|io] [reg|io] [result-reg](result) 130-pop [reg|io](result) 131-push+[im] [reg|num|io] 132-call [label] 133-ret 134-set [reg](result) [num] 135-write_ram+[index_or_not|1] [reg|io] [reg] #可以是0是默认写入1是加入索引,见36 136-write_ram+[index_or_not|0] [reg|io] 137-write_ram+[index_or_not|1] [reg|io] [index] 138-get_ram [reg](index) [reg](result) 139-get_ram+1 [num] [reg](result) 地址表 1-16 reg 17 count 18 io 停更这个系列，等bug修复，如下\n","date":"2025-02-21T09:15:00+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A56/","title":"图灵完备游戏攻略6"},{"content":"图灵完备部分游戏攻略 AI打牌 如果要机器人输，那也就是说，我得把它逼到它不得不取最后一张牌，最后一次行动，以及是，可以限制机器人跟我们之间的取牌，具体怎么限制呢？因为1到3张牌， 一回合我能做到固定一定能拿掉的牌数，是最大数加上最小数，也就是4张，比如说机器人拿1张，我就拿3张，刚好互补上，其他牌数量也一样，方针确定了，接下来就好办了， 1+4+4=9张，也就是说，我第一次就要取掉3张牌，再通过两次每回合\n# take 3 poker add_ii 0 3 7 # 4 poker per bout add_i1 0 in reg0 sub_1i reg0 5 out add_i1 0 in reg0 sub_1i reg0 1 out 我的汇编命名规则参照上一篇文章图灵完备游戏攻略4 不过，看了一下是真优雅，对比起随机存储器那关来说\n半字节乘法 解法其实挺简单的，因为已经被表示成二进制的数了，也就是说$a \\cdot b$ 可以化成\na必定可以被表示成二进制，所以令$a = a_0 \\cdot 2^0 + a_1 \\cdot 2^1+a_2 \\cdot 2^2+a_3 \\cdot 2^3 , b = b_0 \\cdot 2^0 + b_1 \\cdot 2^1+b_2 \\cdot 2^2+b_3 \\cdot 2^3$\n则 $ a \\cdot b = (a_0 \\cdot 2^0 + a_1 \\cdot 2^1+a_2 \\cdot 2^2+a_3 \\cdot 2^3) \\cdot (b_0 \\cdot 2^0 + b_1 \\cdot 2^1+b_2 \\cdot 2^2+b_3 \\cdot 2^3)$\n其中的展开项，其中又有乘2以及2的倍数实际上就等于数字左移，也就是说，可以按一边当作操作数那样然后后面挨个加起来，再有\n$(2^0+2^1+2^2+\u0026hellip;+2^n) \\cdot (2^0+2^1+2^2+\u0026hellip;+2^m) = (2^n-1)(2^m-1) \u0026lt; 2^{n+m}$\n所以两个4位二进制数一定不会在八位上溢出，add上的进位也不需要了，只需要直接加起来就行了\n栈 写到这里，我其实还是挺希望我可以把我所有的思考步骤完整写下来的，但考虑到一方面比较花精力，另一方面感觉这也不是适合放在博客里的东西，有时候会太长了， 如果只是给我自己看我写这一些就已经够了，我也不知道看我博客的其他人是否多，但我感觉基本是我自己而已，有需要的话在我的B站私信或者评论区留言再考虑是否拿出来吧。\n压栈 首先，先清楚两个操作要干什么，压栈和弹栈，分别是push和pop操作，push，也就是写入一个列表里面，想到栈我第一想到的是要用不小的存储空间，也就是先想到了内存， 毕竟寄存器也是只是临时存一下数据，空间毕竟还是太小了，但，根据前面写内存的经验来看，一般需要一个寄存器读取地址位，毕竟可以栈这个玩意，可以理解为指针放在某个位置然后在那附近进行读写或者擦除操作， 需要一个临时的存储工具，也就是寄存器，虽然整个任务比较复杂，但是这些东西构建的时候也不必慌张。\n从简单的入手开始即可，比如我先从压栈操作开始实现，一旦压栈的信号电平变为高电平， 也就是开始执行压栈压入输入的数值，因为考虑到后面弹栈操作也会需要使用这个寄存器，然后再想到这个信号本身是个1bit的信号，如果不想影响其他信号可以通过这个信号到目标处添加一个开关， 然后通过这个信号来控制这个开关，那么一旦这路信号不通的时候，其他路信号控制寄存器的时候就可以被开关隔断，不过，一开始我是寄存器出来的数值直接读入内存寻址位的， 但是这部分在前面的关卡内存读写那边没写好是真的，因为内存初始值指针就是0，然后考虑到还需要累加，那么我在后面直接加入一个add 1就可以了，但是如果压栈操作信号处于低电平了， 我要求add不工作或者工作了输出，所以就有了那个add出门之后的开关，以及是，压栈开启时得开启内存的写入开关，把写入开关连上信号+开关后的输出即可，以及是需要输入端接上一个开关连到内存的输入部分即可\n弹栈 弹栈的操作，第一是先输出完一次运算值，然后对这个值覆写0的操作，也就是其中要同时激活读和写的开关，读先是读出这个位置的数据，输出开关跟弹栈开关相连，压栈操作并不会控制它毕竟， 可以直接连，以及是对寄存器的操作，要求每次写入减1，先实现减1的操作，也就是寄存器输出的值回路连上减法器，减法器，add前面加not并不能直接实现，毕竟直接对1取反是254， 加2才会等于0，也就是说直接就是0位的取反，255,+1就等于0了，实际上是256-1，也就是说加号那边写255或者是0的取反，以及开关操作同上，\n但有一点得注意的是，寄存器输出会有延迟，因为压栈的时候默认的值就是0所以才忽略不计了，然后默认每次+1,每次都可以按时写入，但读取并不是，比如说进行一次压栈操作，寄存器原来是0，输出也是0， 然后配合数值写入0位，寄存器写入1，但是此刻输出还是0，得等下一刻才会变成1，然后下一刻输出1的值，写入没关系，因为原本就放在那个位置，可以是先进行写入再移动指针等待下一刻的写入或者输出， 但弹栈不行，比如说我写入一次之后立刻进行弹栈，此时寄存器的输出是1，也就是原本的值，减法器输出0了，我们知道现在寄存器1的位置因为没有经过读写，是没有东西， 就是默认数值0的，但是我要读写1的位置怎么办呢？直接读写减号后面的输出，那已经经过运算变成0了，以及是输入处被我们禁用输入变成0了，此时可以直接同时接通读和写的开关， 先让输出要输出的值，然后写入0完成覆写，到这基本已经完成了，但是依旧有个小细节，就是，你的弹栈输出部分读和写并不能相连，一旦连上会导致压栈的时候，你一激活写的开关会把读的开关也一并激活了， （当时我输出的开关也连上了后面的线，导致输出也被激活了，实际不应该激活的，如果是直接输出没激活输出了其实也没事）所以我选择用另一个信号+开关的方式来分别激活读和写的信号位。 到此，两个功能就实现结束了\n压栈和弹栈 既然要集成到LEG体系内，就基本必须得给分配一位信号位了，我分配了一个16bit的信号位给压栈和弹栈，然后直接输入输出交互，但是为了以后的可操作性，我把第二位分配成了输入地址位， 然后第四位分配成了输出地址位，第三位置空，其中有个注意事项就是，一旦这一位栈位亮起，意味着前面的运算位的输出得受到抑制，以及是，输出接到第四位没过解码器之前， 然后通过最后一位进入输出位即可，其中下图上方部分得稍加判断输入信号的值\n除法 $29 \\div 18= 1$ ，余数是11\n思路方向：\n$a = a_0 \\cdot 2^0 + a_1 \\cdot 2^1+a_2 \\cdot 2^2+a_3 \\cdot 2^3$\n$b = b_0 \\cdot 2^0 + b_1 \\cdot 2^1+b_2 \\cdot 2^2+b_3 \\cdot 2^3$\n令$a$为被除数吧，$b$为除数，现在的思路如下，先找结果最高位，其中在十进制中，小学的时候学过，除法是先对齐最高位，然后判断最高位处的大小 比如$732 \\div 25$\n$$ \\begin{array}{r|r} \u0026 \\text{29} \\\\ \\hline \\text{25}\u0026 \\text{732} \\\\ \u0026 \\text{-500} \\\\ \\hline \u0026 \\text{232} \\\\ \u0026 \\text{-225} \\\\ \\hline \u0026 \\text{7} \\end{array} $$类似于图中这样的计算过程，二进制也是一样的，十进制乘10就移动一位，二进制乘2就移动移位，计算规则其实一样， 不过最高位得看是否能除的下来，然后一位一位递减判断，能除下来就写1不能除就写0，但这有个例外就是0是被除数得输出错误\n曾经我本来的想法是，第一个不可行了怎么样换第二个条件，实际就有点时间换空间的刻板印象了，实际则是条件$A$满足时运行,也就是$ABC\u0026hellip;$ 然后如果$A$不成立，则补充$\\overline{A}BC\u0026hellip;$,其中$BC\u0026hellip;$为其他条件，也就是意为A不成立时其他条件加入的情况来表示当前状态就可以了，带入到下面的状态就是， 左移被除数到对齐时最高位跟原数进行比较这个事件为$A$事件，然后$BC\u0026hellip;$其余则是比它低的位的情况\n$$ \\frac{a}{b} = \\frac {1 \\cdot 2^m+a_{m-1} \\cdot 2^{m-1}+...+a_0 \\cdot 2^0} {1 \\cdot 2^n+b_{n-1} \\cdot 2^{n-1}+...+b_0 \\cdot 2^0} $$(其中$m$和$n$分别为$a$和$b$的最高位，以及，设定$m\u0026gt;n$), 则\n$$ \\frac{a}{2^\\frac{m} {n} \\cdot b}= \\frac {1 \\cdot 2^m+a_{m-1} \\cdot 2^{m-1}+...+a_0 \\cdot 2^0}{1 \\cdot 2^m+b_{n-1} \\cdot 2^{m-1}+...+b_0 \\cdot 2^{m-n}} $$此时如果$a\u0026gt;2^{\\frac {m}{n}}\\cdot b$则$2^{\\frac {m}{n}}$此位大于$0$,输出的两数比较也就是用比较器比一下$a$和$2^{\\frac{m}{n}} \\cdot b$的大小即可， 如果大于则把该位标记1后减去$2^{\\frac{m}{n}}\\cdot b$然后进入低一位进行判断即可\n实际动手了之后发现可以有复用的地方，如果不复用一部分最后产生的除法运算器实在是太大了，而且线全部要自己拉，所以我选择复用一部分\n但我很快发现了问题，一旦除数和要取的位超过8bit，那么溢出之后将得不出结果了，于是我直接想着，既然已经有16位了，我干脆直接把我的乘法运算器也升级到16位算了， 于是，去调了一下乘法运算器，也就是把原本的16位合并进输出就可以了，如下\n改动完之后发现，比较器如果不升级成16位的也没办法了，于是把比较器也换成了16位的，如果过于溢出就不必输出8位的了，因为被减数都是8bit的，输出也只要指定8bit就可以了， 以及其他的\n其中，如果一旦被除数是0，那么直接ban了其他两位的输出，所以需要开关，另外，排除掉除数是0的状态后，讨论一下输出位是0或者1的情况\n如果是0，也就是说最高位移动后大于被除数，也就是类似$245 \\div 50$这样，最高位处已经输出得是0了，那么余数就原样输出就可以，然后进行到下一轮的循环，也就是取下一位 如果是1，也就是说最高位移动后小于被除数，类似的对比则是$245 \\div 22$,最高位输出是1，余数得输出两数相减，即$a-2^{\\frac {m}{n}} \\cdot b$ 所以余数位得规划两路输出，一路是原数输出，另一路是两数相减的输出，启用一个二选一选择器即可\n搞定完这些之后，除法处输出就轻松了，不用摆那么多东西了\n然后在LEG-ALU模块中加入除法运算器\n到最终这边测试的时候又发现一个问题，我真TM恨啊，你游戏开发者最后平衡也没顾好了，讲真，LEG-ALU里一堆用不上的玩意，塞里面，然后把我可能要用的运算吧， 塞的没法动了，搞的我原本搭好的逻辑框架不想再去动一下\n现在反正有存不同版本的LEG框架，干脆直接就是魔改一个divide版本的ALU出来算了，然后把原本的线路复制出来复制到一个单独的divide线，然后把改完的ALU替换掉原来的ALU，唯一麻烦的地方在于需要重新搞一下指令集\n输入代码后发现依旧有错误，结果是发现div-mid的错误，才发现只有小于号，加了一个or算了，有时候不如自己写一个\n这样这一关就过了，拖了不少时间\n","date":"2025-02-17T21:35:17+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A55/","title":"图灵完备游戏攻略5"},{"content":"图灵完备部分游戏攻略 条件判断 现在可以自定义指令集了，顺带改一改吧就，刚差点没找到怎么移动描述的位置，抓住AND右边的引脚拉到最边上再拖动左边的引脚即可\n通过新建的指令集我们能看到，如果一旦涉及条件判断了，32位是必定亮起的，既然我们之前用过自定义的解码器，这回就得继续在解码器上进行修改了\n逻辑电路的元器件我就不开图了，在之前我已经发过了，链接放在这点击跳转 小于的搞定了，小于等于条件也就是小于+等于也就是加一个或门就可以了，小于等于反面就是大于，也就是前面小于等于取一个反就可以了，大于等于是小于的反面，同样取反， 不等于也就是等于的取反，因为这里涉及1bit的信号8选1嘛，又没有这个元件，只好自己写了一个\n首先先把COND-plus元件加入main中，并顺带蹭一下隔壁ALU的输入，因为都是一样的，其次用八位开关分别控制输出内容的去向，安排完cond-plus先把它的输出放着，来改动另一边的\n说明一下左侧的内容，因为切到条件判断之后，原本是作为地址码输入的第四位，变成了直接修改计时器的值的数，因此，它需要两边都有能过的线，下面一侧直接输入的值， 也就是上面的32位的值，一旦处于1的状态就放行下面这个，使他作为一个数直接输入进计时器，另一侧，原本是直接输入地址码的变成了直接固定以访问计数器栏的值， 也就是说需要一个二选一的数据选择器，一旦条件改变变成执行条件检查就打到6这侧，这就完了么？不，并没有，还记得上面那一侧的COND的输出么？如果COND输出为0， 也就是说条件不成立，那么是否应该拦住去计数器的信号呢？那条画着没放全的线，就作为了右边两处方框的控制开关，如果条件没有成立，那就通过开关来自动关闭，即， 如上\n移位 唔，刚好以前写了，就很离谱，当时写乘法运算器的时候用到了\n当时还采用了两位8bit数的输出，不过看起来这里只需要给一位分配输出就好了，以及还有禁用开关，实际本质上就是把输出的8bit数分线后移位挨个输出，然后另一个按照八位开关考虑好输出哪一位就好了， 原理其实挺简单，实际画的东西相当多就是了\n延迟量 六个单位延迟量，以及是使用五个nand门，结果需要有变化，nand的突变点在于两个高电平会返回低电平，其他时候都是高电平，那也就是说，如果两个口都接一处， 两个信号不同的情况会坍缩了，输出相反，同理，这样可以再接一级，再是最后一个nand再改一次， 随机存储器 讲真，我看到这个要求之后，人有点懵，说实话，已经没有额外的寄存器位置可以供分配了，走线都已经布好了，想要撬开其实怪麻烦的，唯一有点头绪的可能是指令集中依旧没分配的其中两位指令资源， 现在也就考虑16位以及是最后三位的联动了，内存，已知的也就两个功能，读内存和写内存，但是要考虑好怎么搞定，目前实现的就是，一旦涉及内存信号位高电平，意味着这一刻必须断开8位写入器， 也就是通过一定手段激活禁用开关即可。\n但又碰到了麻烦，我调试后才发现，最大的问题在于，，说是说依次读取，但是一个时钟刻就进来一位数，写入的时候并没有什么时间执行其他东西，比如说累加，以及是跳转，要打达成这边的循环得有几个必要条件， 先要有label loop标记循环行，再有if类的条件进行跳转到计数器内进行改变程序执行的位置，其中if和累加必定冲突，if需要占用程序操作位的前3bit，累加需要前三bit是0， 也不可能俩一起出现，如果这样那只有用丑陋的办法了， 就是代码一行一行自己指定内存写入位，十分的丑陋，我目前没想到啥解决办法，也没去看过官方攻略\n以及是，我指定了内存的读和写的两位，写则是16\n过了一些时间才着手解决这个麻烦，想好了思路，先确定好指令样式之后再决定怎么搭线是最好的，题中也就说了一句额外加寄存器，讲真不如直接拿一位的寄存器来当内存地址， 确定好的命令如下:\n内存信号高点平的相关指令 输入位 内存位 输出位 如果是写入状态， OP_write_RAM 写入位 内存地址位 空 OP_read_RAM 空 内存地址读取位 输出位 其实很纠结，因为空了东西了，但确定下来就好办了，其中以下是内存写入的代码\nOP_write_RAM 7 1 0 OP_write_RAM 7 2 0 ... OP_write_RAM 7 31 0 OP_write_RAM 7 0 0 其中OP_read_RAM相关的命令则变成了\nOP_read_RAM 0 reg0 7 说明一下，内存地址读取位是指，从那一位寄存器里读出数据然后来写入，也就是说，只要从第二位选择器中拿到后面的数据就可以了，其中二选一控制器用读的17（控制码）就可以了， 这样可以通过寄存器直接输入数值了就，这样就可以构成循环的条件了，因为题目中没要求输出的时间紧凑度，如果再是上面那样急着输出就很难搞了，接上个话题，比如说我指定reg0为内存地址读取位， 那么我后面指定让reg0累加1，然后判断reg0是否小于等于32就可以了\nlabel loop OP_read_RAM 0 reg0 out add_i1 1 reg0 reg0 lesseq1i reg0 32 loop 其中这是代码，add_i1是指第一位是立即数第二位是reg寄存器地址的，下面的lesseq1i也是一样，指的第二位是立即数模式进来的数字，这样就能解决了\n吐槽一下这个出的问题，太烂了，我很讨厌低效的代码，拷贝，改数字，挺丑陋的，但我又拿它没办法，read部分我其实想破罐破摔了，但是程序本身放不下貌似，溢出了，那就作罢只能换循环了， 这题是解的算扫兴了，希望后面别碰到这样的题了。\n下一篇博文见,下一篇链接(还没更新，更新完了放这里)\n","date":"2025-02-14T15:10:30+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A54/","title":"图灵完备游戏攻略4"},{"content":"图灵完备部分游戏攻略 宽指令 要求偶数刻存储，奇数刻一次输出存储的一个值和本身程序的值，也就是说，我需要调用一个寄存器，然后用一个分线器，查看一下最低位的1的值就知道现在是奇数偶数了， 偶数时刻，比如说0，也就是说1位处于低电平的时候写入寄存器，也就是需要套一个非门，因为程序的输出口还有直接输出到输出的功能，所以最好给程序输出口套一个八位开关，没有低电平的时候直接不输出值， 这样偶数刻的操作就结束了，再有奇数刻要输出两个数的值，也就是说，1位高电平亮起，同时，控制寄存器一位和程序一位分别向输出口输出即可，分别套一个八位开关 如下：\n一把线，像挂面 按照它上面说的，先将计数器步进设置为4\n以及是根据要求说明2里的图，后三个都是操作地址，也就是说，后三个全部需要用到分线装置控制到哪一位，这就可能要点布置\n首先如上改造了一下以前的八选一的数据元器件，改成8bit好方便输入\n后悔没补上ALU的描述，因为刚才报错我以为要求说明4里的add确实是0输入ALU里面的0了，结果不是，ADD在ALU里对应的控制码是4，那我就补一下，因为现在反正也是临时的， 不确定后面的控制码要求是什么样的，毕竟0变成add了，那有可能后面ALU也得改，既然现在它要求只是add那我直接就控制码始终是4输入罢，后面要改了再说\n第一版布线方案用了之后，发现一旦输出是0了，就输入不到寄存器里了，意识到了这么个问题，但想想，好像是因为本身的问题，因为上面一版布线我直接就是为了省控制位的线， 直接用了判断输出是否是0来决定是否要写入寄存器，但明显这是个失误，得补上控制线\n有改动的地方如上，也就是操作码强制被指定4，断开初始操作码，以及是新增控制码\n操作码 只能说，果然不出所料了，控制码有变更了，那也就是意味着，ALU我有条件的话重构一个会好一些了，然后按照对应的控制码调整自定义ALU的位置即可\n最终只要把上述的线给连回去就行了，删掉原来的8bit常数\n立即数 判断是否是立即数模式，我又想造元件了，毕竟，咋说呢，目前8bit后两位是用来判断立即数的，然后前三位是用来判断运算的，估计后面还有加的，不如设计一个元件， 输出对应立即数模式和计算模式，然后输出对应的东西，这样会快一点，直接放在整个LEG框架空间内就显得太拥挤了，曾经就是输出一位判断码，这次直接输出的是所有控制位，感觉也不错\n以下是目前的布局方案，其中左边处通过解码，上面的三位直接通过新的分流方案通过三位数的传递接替了上面的原布线，而下面的两位控制立即数模式，也就是右边做出的改动， 输出的两位是两位控制码，也就是输出的数采用原数还是从寄存器里选出来的数，二选一，所以用了八位数据选择器，这样就能运行的通了\n条件判断 现在可以自定义指令集了，顺带改一改吧就，刚差点没找到怎么移动描述的位置，抓住AND右边的引脚拉到最边上再拖动左边的引脚即可\n下一篇博文见,下一篇链接图灵完备游戏攻略4\n","date":"2025-02-13T16:21:04+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A53/","title":"图灵完备游戏攻略3"},{"content":"图灵完备部分游戏攻略2 异或 目标 虽然它说的是八位数按位进行执行操作的异或，因为已经实现了多个以八位通道进行的计算，所以，某种程度上它可以通过翻看以前的一位异或来参考解法，当时我为了完成成就也搞定了另一种解法，虽然是我蒙出来的\n第一种解法 因为四个NAND实现的元器件实在是太难存储变量了，通过上一篇图灵完备攻略即可得知，额外的只有两个存储位，因为现在不需要立即数模式，所以reg0也可以当作紧急备用，也就是说，满打满算三个存储位， 先读取两个数分别到reg4和reg5，然后计算两数的按位nand的值到reg0（以前从没用过），然后根据后面计算结果覆盖reg4和reg5，因为，毕竟输入的两个数终究也只是两个中间变量，不必要永久存储，实现如下\n# copy two num to reg4 and reg5 in_to_reg4 in_to_reg5 # have a nand operation reg4_to_reg1 reg5_to_reg2 nand # save nand two num to reg0 reg3_to_reg0 # do another two nand to instead the num in reg4 and reg5, reg4\u0026#39;s num is in the reg1 reg0_to_reg2 nand reg3_to_reg4 # do another reg5 reg5_to_reg1 nand reg3_to_reg5 # now nand reg4 and reg5 reg4_to_reg1 reg5_to_reg2 nand reg3_to_out 第二种解法 因为不满足于一种写法，所以我现在来实现第二种，其中Nor的指令我去加一个，还没加入汇编指令集\n如果说上面那种属于是额外生成一个中间变量然后参与跟起初的两个数的运算的话，现在另一种正常的方法看电路就知道，因为再也不需要调用到前面的变量了，直接可以执行覆盖操作，可以说是 先把in的读取到reg1和reg2进行预备的运算，然后可以直接复制中间变量到reg4和reg5，至于输入，用完就可以丢了，\n不过唯一要研究一下的就是，怎么对一个数进行按位的取反就是了，虽然这在单个电路里是个简单的事，但毕竟已经有程序了，肯定还是用现成的东西去实现，以及，立即数模式虽然没办法生成255这个值（到64位以上就已经是控制码了） 但是要生成可以通过两个运算数都是0的情况下进行nand运算即可得到255\n多看两眼算数引擎，好像可以直接拿那边的八位的not来用感觉？先有一路经过nand的数进行了一下八路not运算，到or这，也就是只要保持另一路是0就可以保证or直接输出单路了 那么也就是对应过来另一路输出就是需要是255，怎么得来就可以通过reg0原本就没使用过输出到reg1和reg2进行nand或者nor运算得到，思路确定了，也就只剩下编写代码了\n# copy two num to reg4 and reg5 in_to_reg1 in_to_reg2 # do first operation nor reg3_to_reg4 # do second operation nand reg3_to_reg5 # set 0 to reg1 and reg2 to get 255 reg0_to_reg1 reg0_to_reg2 nand # set 255 num to reg0 reg3_to_reg0 # Set two numbers that will be operated on reg3_to_reg1 reg5_to_reg2 nand reg3_to_reg5 # do OR operation to the num in reg4 and reg5 reg4_to_reg1 reg5_to_reg2 or # final operation reg3_to_reg1 reg0_to_reg2 nand reg3_to_out 最终因为not麻烦一点依旧是用了4个nand计算方法吧，最后依旧也是跟上面一样，调用了立即数的出口reg0存储了255来直接使用nand运算打成not的效果，怪麻烦的。\n八位常数 这，好像只要指定八位集线器然后用高电平直接控制对应位置就好了，低电平都可以不放了 相等 说起相等，前面这一圈下来，好像确实没有涉及跟相等有关的布尔值输出来着，前面也有想要这样判断的并没有 也有两种思路，一种是先用sub减法一样的电路把两个8位数相减，然后确认出来的值是不是0就行了，也就是or8路线路，检查是否是0就行了，第二种是直接八位分线器出来然后一个一个同或比较，最后and8位输出\n思路1 思路2 8位异或 因为8bit已经有了对应的上面对应只有一位情况的所有运算器件， 所以只要根据上面一位异或换成8bit的版本即可\n无符号小于 第一反应是直接相减后判断大小，a\u0026lt;b,也就是证明b-a\u0026gt;0，那也就是说，使用两个相减判断符号就行了，吗？一旦a作为第一位输入是8，作为被减数，然后先取一个反， 但按位取反一旦变成无符号整数，那就已经不一定奏效了，一位一位比较也比较麻烦，其中无符号状态下的取反，b-a实际上成了b+(255-a),也就是255+b-a，如果b-a 大于0，那么255加上b-a必定大于0，也就是说，如果进位信号有显示，那么b就是大于a的，也就是输出高电平，刚好跟进位信号对上了，也不用取反了\n有符号小于 看到这个条件，也就是说，128的地方变成-128了，就要去稍微翻一下相反数的那个元器件了，因为，如果是带符号的，那也就意味着，b-a=b+(-a),而又有相反数等于它本身按位取反之后， 再在加法器上加一得到的，那也就是说，这个加1，我可以当作进位运算，但依旧遇到了点问题，因为，一旦像是如下图这般的，存储溢出了就会失效，进位信号不可用不说，输出直接变成负数， 但最重要的问题在于，这个溢出不好控制，最后一位一旦填上负数之后就不好说了，因为有其他情况也会出现负数\n进行一下完整的分析，设定x,y\u0026gt;0,执行操作每次为第二个数减第一个数，其中-(-128+1)为not的输出，上面但实际最后一位第八位是作为负号位的，进到这位属于溢出，但并没有让加法器溢出，\n1. 第一个数为-x,第二个数为-y: -(-x+1)-y+1 = x-y，这个数可大于0可小于0，需要判断符号，可能会有进位\n2. 第一个数为x,第二个数为-y: -(x+1)-y+1 = -x-y, 必定小于0，但溢出可能大于0，有进位信号\n3. 第一个数为-x,第二个数为y : -(-x+1)+y+1 = y+x, 必定大于0，但溢出有可能小于0，无进位信号\n4. 第一个数为x,第二个数为y : -(x+1)+y+1 = y-x, 这个数可大于0可小于0，需要判断符号\n在那之前，最好先给两者判断一下-128位的信号，至于等于0的情况再考虑,其他小于0的情况可以直接默认不输出，比如case2 其他情况剩下case1和case4\ncase1\n第一张图，x=128\u0026gt;y = 96,取反之后也更靠近128，而y比x距离128稍远些，边界情况如图三所示，刚好所有值都对应上，也就是说如果x=y,两个加起来刚好进位 但add处等于0 也就是说\n1.1 进位信号有，输出信号的总和端口等于0 =\u0026gt; 两数相等 (总和是个输出端口名)\n1.2 进位信号有，输出信号的总和端口大于0 =\u0026gt; -y\u0026gt;-x，第二个数大于第一个数，需要输出1\n1.3 进位信号无 =\u0026gt; -y\u0026lt;-x,不需要输出\n其中直接连入输出了，需要一个开关控制，其中两头直接由两个输入的-128位控制，如果两个数都是高电平才触发上面的，其中中间一位可以开关直接连到case3的输出上， 毕竟开关触发条件也是跟case3一样的，下面-128低电平，上面-128高电平\n同理\n3.2 进位信号有，总和端口等于0 =\u0026gt; 两数相等\n3.1 进位信号有，输出信号的总和端口大于0，y\u0026gt;x 需要输出1\n1.3 进位信号无 =\u0026gt; -y\u0026lt;-x,不需要输出\n仔细一观察，80 48时，除开两处-128信号不同以外，其余部分全部相同，也就是说，现在属于两者同时是1或者0的时候即可成立，那么不用多画了，直接把控制开关的与门替换成同或门即可\n下一篇博文见,下一篇链接图灵完备游戏攻略3\n","date":"2025-02-12T15:23:34+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A52/","title":"图灵完备游戏攻略2"},{"content":"SSLError 这是我曾经新开的一个仓库下的提交的ISSUE，虽然没多少人看过了，\n解决办法 GitHub仓库链接\nwindows环境下当你遇到了这个问题,可以尝试打开 设置-\u0026gt;网络与Internet-\u0026gt;代理 , 手动设置代理处找到地址和端口,并将它们拼接起来,例如\nhttps\u0026#34;:\u0026#34;127.0.0.1:4780\u0026#34; , 在用request.get的时候当作参数传入, 例如\nproxies = {\u0026#34;https\u0026#34;:\u0026#34;127.0.0.1:4780\u0026#34;} 然后传入时,需要把proxies字段作为参数传入\nrequests.get(url=url,headers=headers,proxies=proxies) 以及注意代理的使用情况,如果没有设置代理状态有可能会返回报错,注释掉proxies并删除参数即可. pip同理,复制下列代码至txt文本后,根据你设置内的代理状态进行修改,然后在cmd运行 例如我的是pip config set global.proxy 127.0.0.1:4780(地址和端口记得改成自己的)但如若你需要关闭VPN使用pip命令记得用下面一行代码, pip config unset global.proxy即可.\n最近逛了一圈倒是找到了对应的文章，当时碰到的时候没有任何的提示\n当时还在大学，时间紧，试通之后并没有去查到底是什么原因导致的，好像是urllib库的问题，当时问GPT也没有任何结果，最近去问了问deepseek也依旧不明白报错原因\n其他人说了原理的话我也不多说了网页链接，我也没有仔细去钻研过这个玩意，当时只是发现了解决办法， 但实际具体看了一下他们的东西也不一定能照搬过来，具体见\n报错 HTTPSConnectionPool(host=\u0026#39;api.live.bilibili.com\u0026#39;, port=443): Max retries exceeded with url: /xlive/web-room/v1/dM/gethistory?roomid=10112\u0026amp;csrf_token= (Caused by SSLError(SSLEOFError(8, \u0026#39;EOF occurred in violation of protocol (_ssl.c:1123)\u0026#39;))) 出错形式会有很多种，proxyError,以及是最常见的是SSLError\n高版本python目前已经修复了这个问题，python3.11已经不用担心这个问题了，python3.9还存在这个问题。 我现在也只是给一下低版本的一些解决方案，虽然可能比较麻烦，如果说在开发的过程中你已经全配置好了其他的比较难改了，那推荐你强制你的用户用高版本的python，我目前并没有测试过python3.10附近的，也没查出啥时候修复的 3.11以其版本以后的都不用如此手动配置代理了\n如何修正 以下是两段的参考代码,我目前的版本是Python 3.9.2rc1\ndef get_proxy_settings(): \u0026#34;\u0026#34;\u0026#34;代理配置函数，如果有代理直接返回代理环路地址:端口号，代理地址一般是127.0.0.1，端口号:4780，则拿到的返回可能是127.0.0.1:4780\u0026#34;\u0026#34;\u0026#34; try: with winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\u0026#39;Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\u0026#39;) as key: proxy_server, _ = winreg.QueryValueEx(key, \u0026#39;ProxyServer\u0026#39;) return proxy_server except FileNotFoundError: return None # 其他内容 if get_proxy_settings() != None: proxies = {\u0026#34;https\u0026#34;: get_proxy_settings()} #设置proxies,此处http不一定是必要的，以及127.0.0.1:4780前面的https也不一定是必要的，如果有错误可以试试 res = requests.get(url,headers= headers,proxies=proxies) else: res = requests.get(url,headers= headers) # 其余操作 pass 这一段逻辑代码我用在过我的另一个翻译脚本上,端口一般不会变化，其实设定好了就一般不必多更改了，可以当作固定接口用的，除非你反复用不同的VPN，具体如何我也没测试过，这一段代码被我当作了 扩低版本python兼容性的解决方案，因为很有可能会出现\n由上两图可见，在python版本号是 Python 3.9.2rc1 时https处并不能加任何东西，如果加了东西，可能就会导致内容报SSLError错误\n另一种获取代理配置的方法比上述可能简单一点，但我没怎么用过，也就是urllib.request.getproxies函数,要筛除一下无关元素太麻烦了，以下是输出示例，如果你觉得 会比上述内容方便的话可以试着改一改，但我已经不想动了，要做的也就是去掉https键对应的值的https字符串，至于其他是否保留也取决于自己，仅供参考\nurllib.request.getproxies() Out[10]: {\u0026#39;http\u0026#39;: \u0026#39;http://127.0.0.1:4780\u0026#39;, \u0026#39;https\u0026#39;: \u0026#39;https://127.0.0.1:4780\u0026#39;, \u0026#39;ftp\u0026#39;: \u0026#39;ftp://127.0.0.1:4780\u0026#39;} ","date":"2025-02-11T16:35:53+08:00","image":"https://adeepblue.github.io/p/python-%E5%BC%80%E4%BA%86%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8requests%E5%BA%93%E6%8A%A5%E9%94%99ssl-error%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/Logo_hu_4ab870606288912a.png","permalink":"https://adeepblue.github.io/p/python-%E5%BC%80%E4%BA%86%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8requests%E5%BA%93%E6%8A%A5%E9%94%99ssl-error%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","title":"Python 开了代理使用requests库报错SSL Error解决办法"},{"content":"分享关闭LM studio开机启动的方法 关闭方法 关闭无头开关(headless)就可以不让LMstudio开机启动 我是如何找到的 之前搜了一圈发现没找到来着，虽然B站发了，但是这里还是再发一篇吧，这是B站这边的链接网页链接,区别在于我会在这里讲一下我是怎么找到这个的\n没找到显式开关的情况下，当时搜谷歌时候的内容如上，其他内容几乎没有，当时觉得挺绝望的，一个半开源软件把开机自启开关都藏得这么深的么？甚至还没多少人关注这个，只是说了它支持开机启动，其中的更新日志里， 那，换个说法，之前的状态就是不支持开机启动咯，那你总有开关做着让人选的吧？\n开机启动，我第一个想到的就是任务管理器里的启动，去看了一眼\n这个选项明晃晃的躺在里面，那基本就是了，假定，如果这个软件只是安装的的时候通过某种手段去修改了一次设置，也有可能是每次启动修改设置吧？按照这个逻辑，我去设置那边关闭了一次这个选项企图看看什么情况，至于说要怎么观察， 关闭软件然后重新启动就可以，毕竟如果是后者的话，一旦修改成功就会观察到吧？\n然后，就真的，观察到启动一次软件就把这个开关给打开了，说明，这是每次启动一旦检测到软件内一个设置选项是啥样的就会去改任务管理器里的那个开关,\n再之后，我考虑到有可能是注册表注册了某个键值，导致的反复修改设置里的选项，不过没找到开关就是了，按照LM studio的名字搜了之后加上AI帮助倒是搜到了开机启动项的位置，以及我其他设定的几个开机启动项\n以及又按照上述方法测试了一下，只是这次直接就是删除相关键值，依旧也是上面的结果，也就是坐实了就是有个设置项，再结合上述日志提到的无头开关，它只提到了最小化托盘选项开关的事，开机启动只是带过了一嘴， 那我有理由怀疑，这个开关同时也控制着开机启动？\n结果，一测试，还真是，任务管理器内的启动那边，和注册表这边的，同时变了\n那也就彻彻底底确定了，就是那个开关的问题，但这个开关同时写了允许最小化托盘的选项，以及是开机启动选项，我估计多少会引起一些不希望开机启动但是可以有最小化托盘的用户的不满了，但既然软件现在也就做了一个开关， 这些用户可能也只能无可奈何接受了。\n","date":"2025-02-08T13:52:52+08:00","image":"https://adeepblue.github.io/p/%E5%85%B3%E9%97%AD-lm-studio%E7%9A%84%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/LM-studio_hu_140794ac5fa49a14.jpg","permalink":"https://adeepblue.github.io/p/%E5%85%B3%E9%97%AD-lm-studio%E7%9A%84%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/","title":"关闭 LM studio的开机启动"},{"content":"Python Matplotlib绘图库介绍 安装库 没啥好说的，pip install 一下就行\npip install matplotlib 使用基础 import matplotlib.pyplot as plt 以下默认你已经安装好matplotlib库并都已经在新建的py文件中加入了以上调用这个库的命令\n最简单的使用命令，也就是一行x一行y的数字输入进plot函数。 下面一步一步讲解:\n首先先给x和y进行赋值，以以下的赋值操作为例\nx = [1,2,3,4,5,6,7] y = [1,0,-1,-2,-3,-4,-3] plt.plot(x,y) plt.show() 赋值完毕之后直接进行plot操作读入类似缓存区的位置，然后再由plt.show()输出包含着图表 (figure) 的窗口\n同时绘制多条直线？ x = [[1,2,3,4,5,6,7], [1,2,3,4,5,6,7]] y = [[1,0,-1,-2,-3,-4,-3], [1,2,3,4,5,6,8]] 没错，我第一反应也是这个，但把数据输入进去就知道不对劲了，我们按照这个方法把图输入进去\nplt.plot(x, y) plt.show() 但输出完就傻眼了，什么情况? 别急，仔细观察图表里，总共有6条线，刚好对应了列表x的长度-1,另一个1去哪里了？(1,1)和(1,1)重合了，变成点了 也就是说，先前预想的按照以下方法绘制的想法落空了,预想的是同时两列x,y一起绘制，，画出两条线\nx 1 2 3 4 5 6 7 y 1 0 -1 -2 -3 -4 -3 x 1 2 3 4 5 6 7 y 1 2 3 4 5 6 8 而现在则成了，左边两列的x和y分别表示作为一个点，跟右边两列也分别表示作为一个点，然后这两个点连起来\nx y x y 1 1 1 1 2 0 2 2 3 -1 3 3 4 -2 4 4 5 -3 5 5 6 -4 6 6 7 -3 7 8 好像比较麻烦？但没关系，numpy有矩阵转置功能 就是要先把x强制转成矩阵\n转矩阵后转置本身 先导入numpy包，一般取别名作np\nimport numpy as np 强制把x和y转为矩阵\nx = np.array(x) y = np.array(y) 然后把转置矩阵赋值给本身\nx = x.T y = y.T 如果你到python控制台做完这些去看x和y的结果就会得到类似下面的结果，y也相同，此时对x和y进行绘图操作就可以得到想要的图了\nprint(x) [[1 1] [2 2] [3 3] [4 4] [5 5] [6 6] [7 7]] 顺带一提，矩阵和包含数的列表都可以被matplotlib接收 此时plot(x,y)即可得到结果 不同区域显示？ plt库包含subplot功能，可以进行一张figure的多个区域的分割，用法则是,plt.subplot()结束表示在你表示的区域绘图 其中可以用简单的数字来表示，第一个数字表示把宽分隔成多少行,第二个数字表示把长分割成多少列，比如说plt.subplot(4,4,1)最后一个数表示 位置，其中三个数都小于9可以直接写在一起,plt.subplot(441)\nsubplot(441) subplot(445) 示例代码\nplt.subplot(4,4,5) plt.plot(x, y) plt.show() 也支持同时绘制\nplt.subplot(4,4,5) plt.plot(x, y) plt.subplot(4,4,1) plt.plot(x, y) plt.show() 这里别急着直接plt.show(),已有subplot()选中某块区域绘制的情况下，再有subplot等于是切换区域绘制 最后都绘制完了就可以plt.show()了\n更进阶的方法 plt.subplot2grid((3,3),(0,0),colspan=3,rowspan=1) plt.plot(x, y) plt.subplot(3,3,4) plt.plot(x, y) plt.show() 效果 利用subplot2grid函数也可以实现这一点，其中(3,3)是前面横竖分割，(0,0)表示起始位置，然后后两个参数表示从左上(0,0)往右下两个方向分别扩张的距离\n一些配置 # 图表标题 plt.title(\u0026#34;title1\u0026#34;) # x轴上的标签 plt.xlabel(\u0026#34;dB\u0026#34;) # y轴上的标签 plt.ylabel(\u0026#34;Hz\u0026#34;) # 打开网格(默认false) plt.grid(\u0026#34;true\u0026#34;) 其他绘制函数 散点图\nplt.scatter(x,y) plt.show() 效果 柱状图\nplt.bar(x,y) plt.show() 效果 读取图片展示在图表上，当时翻函数翻到了，没想到除了cv2，plt也有读入图片文件的函数\n# 需要当前目录有picture.png # 载入图片到img1变量 img1 = plt.imread(\u0026#34;picture.png\u0026#34;) # 把变量载入暂存区 plt.imshow(img1) # 展示图片 plt.show() ","date":"2025-02-07T19:00:05+08:00","image":"https://adeepblue.github.io/p/python-matplotlib%E7%BB%98%E5%9B%BE%E5%BA%93/matplotlib_hu_db27174f46f1de3.png","permalink":"https://adeepblue.github.io/p/python-matplotlib%E7%BB%98%E5%9B%BE%E5%BA%93/","title":"Python Matplotlib绘图库"},{"content":"图灵完备部分游戏攻略 前言 话说在前面，因为先前并没有开博客网站，我先前的内容，除非我再去玩一次，可能会再写记录，目前估计不打算写了 ,目前的进度如下图，已经造出了可以运行的计算机，也实现了简单的几个程序，以及开始了游戏内的汇编，会简单讲一下我造的计算机的布局， 我并不打算多看教程，基本多数是我自己在思考然后自己搞定的，写这个博客的目的是在我写一些程序或者跟程序相关的东西的时候留下一些痕迹， 不写就有可能会像我python这里这边这样，用过3D的绘图但回过头来不知道文件夹放在哪了，甚至还很难搜到，干脆就写博客了就\n目前计算机的布局 这是我目前造好的计算机，如下图\n寄存器 下面的是6个寄存器和一个输入，可以用来存储读取数据 DEC状态选择器 以及是DEC，模式选择器，选择当前计算机处于什么状态，主要是取决于从程序码中读取的8位状态数中的前两位，这两位组成一个 二进制数表示0到4，分别代表DEC的四个模式从上到下分别对应0-3，对应着四种读写模式，接下来会介绍四种模式\n四种模式 立即数模式 模式0是IMMEDIATE(立即数模式) ，它会读取后面的六位直接存储在reg0中，\n# 直接写数据会把程序码变成这个数,小于64时前两位数字都是0，立即数模式直接把1写入reg0 1 计算模式 接下来是模式1，计算模式，如箭头所示，reg1的输出会到ALU元件的输入1部分，reg2的输出会到ALU元件的输入2部分 其中ALU的输出通过一个二选一线连到了reg3的输入端，在模式是计算模式下，reg3的读写开关时打开的,至于ALU是什么在下一步处讲 现在可以理解为，输入1跟输入2经过ALU的一翻操作之后输出变成了reg3的值，这些都是基于先前给的指令集添加的功能，以下是之前的游戏要求，也就是 现在已经实现了的东西，指令码是最后三位\n在这个基础上,我新增了两数相乘的功能，也就是现在写着的unused的地方，现在已经这个按键位置可以实现乘法的功能了\n以及，这个指令的操作意味着，我先设定好reg2和reg1的值之后，我只要输入这个指令就可以把以上能得到的结果输入到reg3，至于怎么设定reg1和reg2的值后面会说\n复制模式 再然后是模式2,copy模式，数字复制模式，这个指令会执行的操作是从前三位指代的寄存器的位置复制数值到后三位指代的寄存器上 也有特殊的，三位值如果指代的是6，也就是110的状态下，左侧三位指代的输入，右侧三位指代的输出\n条件判断模式 模式3，条件判断模式，条件是否满足如上，检测到reg3是否满足条件，满足后把reg0的值输入到程序的计数器内，也就是 可以实现跳转功能\n汇编 可以为你已经有的指令创建一个别名，然后在程序中执行时，这个别名会被对应的指令数字替换，这样做可以增加 代码的可读性，让你知道当前代码什么意思，也就构成了现在的汇编代码编辑器的页面现在已有的东西，其中立即数模式不需要汇编，因为当前两位是0的时候后面的作为数字直接进入reg0. 计算模式直接写对应的模式的英文，比如add，当然，在执行汇编命令add，也就是68之前，需要将reg1和reg2赋值完毕再计算 如果没赋值就进行计算在多数情况下没有意义，至于复制模式，已经将相当多的指令直接指定好汇编别名了，现在能看到的基本都是以 哪to哪的格式进行命名的，至于第四个条件模式，一般用于代码的循环吧，等于是重新跳转到哪里执行，会在下面一个模块中描述，目前定义了 if_reg3_not0,也就是reg3不等于0，以及一个always命令，见条件判断模式中的100\n基础已经能实现的一些功能 综上，已经明白reg0到reg3都是已经有功能附加在身了，能自由控制的也就是reg4和reg5的值了，先说一个可类似for循环的操作， 先定义一个数，到reg4比如说，初始化可以通过立即数模式加复制模式完成，下面是举例\n4 reg0_to_reg4 现在以及执行的命令有，我先将10赋值给reg0，然后再把reg0(10)的值赋值给reg4，从而完成了循环数的初始化 再有就是条件变动了，因为几乎所有的条件几乎都围绕着0附近展开的，所以一般情况下的循环就是从你定义了一个数，慢慢 下降，到0为止，停止跳转操作：\n跳转操作，修改的计数器的位置，等同于修改了下一个要执行的程序命令，比如说条件成立之后，我计数器变为3，原来是10再次碰上跳转时依旧会跳转到3 那么如果我加入一个条件数进行限制呢？一定条件下不运作了，最简单的实现就是，一个数，每次操作完都减一，然后等到0的时候停止执行，这是可能的最简便的方法吧？ 事实上也是如此，当初我没写乘法运算器之前，也就是通过循环一个数直到它为0的操作来实现乘法的操作的，前面有关卡 实际也就是类似等同于python中以下的代码运算，但这里毕竟程序执行一次的时间肉眼可见，至少当时执行乘法的操作的时候 当时计算的很慢，也就是进行了一次时间换空间的操作，用循环数的方法，消耗了first_num倍率的时间，进行了一次乘法操作，我写的乘法器只需要一次的 计数器累加次数，相比下面部分完全写好的循环部分，多的是不少的计数器累加次数，实际上这就是计算机内部的时钟频率，基于时钟频率进行的执行各种程序操作\nsum_num = 0 first_num = 6 second_num = 4 for index in range(first_num): sum_num = sum_num + second_num 啰嗦了不少东西，现在完善一下以上曾经实现的类似上面python代码的操作，已经提到初始化好loop_num了\nlabel loop # 初始化减数(操作数1对操作数2进行操作，顺序是如此定的，比如4-1，第二位就是1) 1 reg0_to_reg2 label会标记当前行的行号,比如说这里是第四个代码执行行（注释操作并不会占用代码执行行，会被忽略） label的定义的关键字是loop，也就是，后面如果读到是loop的话，就输出4，一般我的习惯性操作就是，把reg0的值复制到reg3来，然后 直接让reg3判断是否已经满足条件，如果条件满足，那就是进行跳转，但执行if_reg_not0的时候reg3已经有数值了，所以 loop得放到if_reg_not0前面,继续上述代码\nreg5_tor_reg1 in_to_reg2 # 执行加法操作，被加数是输入数 add # 执行完后把输出数复制回reg5 reg3_to_reg5 # 输出循环数行到reg0 # 复制reg4到reg1 reg4_to_reg1 # 执行减法操作，并将输出值赋值给reg3 sub # 输出完刚好直接检验减完1之后的值是否是0 # 先初始化好reg0的值，如果reg3条件成立就跳转到label loop那行执行 loop # 判断！ if_reg3_not0 # 如果执行完毕，输出reg5累加数 reg5_to_out 关卡密码锁 \u0026mdash;2025 02 06记录 看到第一想法是，想组织二分法去快速取值了，但想想简单吧还是遍历简单，所以准备 直接写两个程序，一个遍历一个二分法取值,以下是从游戏内汇编代码编辑器中拷贝过来的代码，但现在转念一想，我好像， 如果使用二分法得写一个除法程序，先放一放，得思考一下除法程序的思路，以及是除数为0的报错处理方法，但先放着了，后面再说， 以下是目前的遍历代码\n# put in every num to the output 1 reg0_to_reg2 0 reg0_to_reg4 reg4_to_out label output_loop reg4_to_reg1 add reg3_to_reg4 reg4_to_out output_loop always \u0026mdash;2025 02 09记录\n对4取模 需要对一个数模4的结果等效于 4 % 3 因为模的数是4，是2的倍数，也就是说，我只需要拿到这个数的最后两位就好了，看到这个我第一反应是，直接移位，我写乘法器的过程中有使用过移位的一个计算工具，\n但现在去细看ALU元件输入输出我才意识到，取最后两位我可以让一个数的最后两位同时亮起然后进行and操作，也就是说，其他部分全是0的地方，会被直接不并入计算，\n想明白这个之后我瞬间意识到，前面的移位的器件可能能优化，但转念一想也不对，因为这个移位操作，要独立的1，2，4，8，16这样的2的倍数，依旧是需要生成8位通道的，也不一定能做成这个优化\n3 reg0_to_reg2 in_to_reg1 and reg3_to_out 这关就走通了\n迷宫 这玩意就让我想到了以前有说的，摸着墙走通关什么的，但该说不说确实可行，以左转为例，逻辑也就是左转，碰墙就转弯\n这样逻辑可行但总感觉少吃了点金币（贪），但好像也有办法实现，先看看正常的实现吧，实现完了再去看看\n根据以上最先写好的肯定是直接const好机器人的指令，总是用0，1的来看终究还是不方便 const left_num 0 const advance_num 1 const right_num 2 const get_object 4 const stay 3 细致来考虑一下，先检测当前前方物体，是墙右转，如果一直是墙就一直右转（总不能被四处围着吧），如果不是墙，是跳转到直行处执行直行操作，但是一开始我对这样的if操作有点犹豫，因为考虑到可能比如左转\n不管了，先来画个思维导图吧，如果全部要在脑子里面实现感觉又会卡不少时间了，画好了，如下\n# init the sub_num for judging if the object is wall or not 1 reg0_to_reg2 label left_loop # turn left left_num reg0_to_out # judge object get_object in_to_reg1 sub # if it\u0026#39;s wall, it\u0026#39;ll change the count num turn_left_but_not_wall if_reg3_not0 # if this code to end will be executed, that means the left is wall ... # end turn_left_but_not_wall advance_num reg0_to_out left_loop always 要做的事已经在上面有所备注，其中我也算是明白了，有些函数为什么要放在末尾，在matlab里，可能类似就是这样的实现吧，因为对于这个语言来说放在开头可能会覆盖其他执行顺序， 虽然也只是我猜的, 放在最末尾然后重新跳转回前面的一个位置，如同上述代码，这样就完成了左转，不是墙分支的代码实现\n开始实现下一个分支，也就第一个选项是墙的情况\nright_num reg0_to_out get_object in_to_reg1 sub second_judge_not_wall if_reg3_not0 # if it\u0026#39;s wall,turn right and stay # in the same place #end label second_judge_not_wall advance_num reg0_to_out left_loop always 但在这里发现，第二次判断好像跟第一次判断有重合的地方，我可以直接合并成advance分支，执行完直接回loop就行了\n这里解释一下，右转原地待命由于右转本来就占用了一个机器人的执行时间单位了，以及迷宫没有对时间的要求，所以stay原地待命操作可以直接不执行，只要执行转向即可跳转\n不好意思上面get_object忘记给输出了，需要都补上reg0_to_out才能把物品ID返回输入\nconst left_num 0 const advance_num 1 const right_num 2 const get_object 4 const stay 3 # gold_id 8 # wall_id 1 # nothing 0 # door 3 # init the sub_num for judging if the object is wall or not 1 reg0_to_reg2 label left_loop # turn left left_num reg0_to_out # judge object get_object reg0_to_out in_to_reg1 sub # if it\u0026#39;s wall, it\u0026#39;ll change the count num advance if_reg3_not0 # if this code to end will be executed, that means the left is wall right_num reg0_to_out get_object reg0_to_out in_to_reg1 sub # if it\u0026#39;s not wall, advance advance if_reg3_not0 # if it\u0026#39;s wall,turn right and stay in the same place right_num reg0_to_out left_loop always # end label advance advance_num reg0_to_out left_loop always 因为东西太满了，我打算新开一篇，下一篇链接图灵完备游戏攻略2\n","date":"2025-02-06T10:07:57+08:00","image":"https://adeepblue.github.io/image/Turing-Complete-Logo.png","permalink":"https://adeepblue.github.io/p/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/","title":"图灵完备游戏攻略"},{"content":"CMD一些命令介绍 先新建一个cmd窗口，可以使用Win + R打开运行窗口中输入cmd打开，也可以在地址栏输入cmd打开cmd窗口，如下,不过还是第二种方法常用，因为第一种需要重新切换目录， 除非你只是需要开一个cmd窗口，第二种可以基于当前环境下开cmd窗口，运行窗口打开的cmd，通常是基于你的用户名的 C:\\Users\\Deepblue\u0026gt;你当前登录的用户是什么，一般就会显示在这，至于地址栏开启的，比如上面从文件资源管理器的地址栏打开的，打开显示的页面就是 E:\\personal-blog\\personal-blog\u0026gt;基于当前页面的窗口，也叫工作目录\n切换目录，创建目录，创建文件，查看当前目录下的文件 dir 用于显示你当前目录下的文件和文件名以及其他一些详细信息的 一些我用的多的参数：\n/s:你可以通过跟上/s的方式递归查看它的所有子目录里的文件 /b:忽略其他的输出信息 如果后面跟一些类正则的表达式则可以搜索目录下的一些文件或者目录，一般我平常习惯用的就是文件资源管理器下打开这个，然后用dir [给定的搜索条件] /s/b来搜索自己想要的文件 举个例子:\ndir *.apk /s/b 表示搜索当前目录下的以apk结尾的文件，其中*表示通配一切字符，跟正则库不太一样的是，这里直接就是*，而要调用正则的话则是.*,后者.表示统配一切字符，然后*表示若干前面前面的字符 不限制数量，有多少匹配多少，前者也表示这个意思，所以说，如果你需要查找什么带某个字符的文件名，比如说我只记得这个软件的部分文件名，就可以这样做\nE:\\软件\u0026gt;dir *spacesniffer* /s/b E:\\软件\\spacesniffer_1_3_0_2 E:\\软件\\spacesniffer_1_3_0_2\\SpaceSniffer.exe E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2 E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2.zip E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2\\SpaceSniffer.exe E:\\软件\\资源类软件\\spacesniffer_1_3_0_2.zip cd 假设我当前工作目录如下 E:\\personal-blog\\personal-blog\u0026gt; 其中打开dir查看了一眼这个目录下的所有文件，如下，然后，我想让工作目录切换到已经标记了assets的文件夹，那么直接在命令行输入 cd assets就可以切入assets目录了\nE:\\personal-blog\\personal-blog\u0026gt;dir 驱动器 E 中的卷是 980 卷的序列号是 B407-DA03 E:\\personal-blog\\personal-blog 的目录 2025/02/09 15:41 \u0026lt;DIR\u0026gt; . 2025/02/09 15:41 \u0026lt;DIR\u0026gt; .. 2025/02/09 12:59 \u0026lt;DIR\u0026gt; assets REM --此处文件夹已经被删去多处，为了节省显示空间-- 4 个文件 7,917 字节 12 个目录 245,086,658,560 可用字节 观察到前缀显示多了assets即表示成功切入，补充一点，cmd有补全机制，会识别你当前的参数部分是否是当前文件文件夹下的，比如说这里可能 敲个ass再按tab就可以补全assets文件夹的全称了,也可以同时串起切入多个文件目录，比如说cd ./assets/scss，切入多个嵌套并没有任何影响\nE:\\personal-blog\\personal-blog\u0026gt;cd assets E:\\personal-blog\\personal-blog\\assets\u0026gt; 如果需要回退父目录，比如说上面这段我想切到E:\\personal-blog\\personal-blog文件目录，则只需要敲入 cd .. 即可切出\n创建文件和创建目录 mkdir\n在当前目录下创建一个文件夹，记得复制完文件目录以后把斜杠改成反斜杠，起初我以为是用斜杠/来实现分割目录，结果后面发现是反斜杠，就，挺不方便的，得稍微注意一点，其中 mkdir .\\a\\b\\c\\d可以递归创建文件，也就是，当前并不存在a以及下面的所有目录，这一行命令就可以一次性创建所有使得cd .\\a\\b\\c\\d可以直接访问了\n基于当前目录下创建 ~.\\a\\b\\c\\d的目录\ntouch 同样的文件分割方式，创建文件可以用touch函数 touch .\\a\\b\\c\\d\\e.txt 但注意，创建的是空文件，一般结合mkdir使用\n打印输出，定义变量和环境变量 echo\n顾名思义，类似于python中print的功能 语法则是echo [输出内容]，如果输出内容包含空格，需要英文双引号包裹输出内容两侧 set\n可以临时定义变量，set \u0026quot;a=1\u0026quot;不过需要被包裹在双引号里面，调用的时候需要%a%来调用即可，比如说echo %a%,也可在%a%前后加入内容，比如说\u0026quot;echo 1-%a%\u0026ldquo;输出1-1\n环境变量 一般情况下，你输入其他目录的文件，通常cmd不会给出回应，但如果你将目标目录的文件夹路径添加到环境变量后，那么你就可以访问了，比如说你添加了hugo的源目录 D:\\hugo_extended_withdeploy_0.143.0_windows-amd64,其中下面有hugo.exe 那么你直接通过cmd敲入hugo相关的相关的命令即可在当前目录下使用hugo了， 很多时候这相当有用，其中环境变量可以通过win+S呼出搜索框然后输入环境变量打开对应的设置选项即可，而我，我更懒，我直接新建了一个快捷方式，填入了C:\\Windows\\System32\\SystemPropertiesAdvanced.exe 并把快捷方式命名成了environment，然后把这个快捷方式加入了环境变量，然后，我就可以很方便的通过win R运行框中输入environment进行直接打开环境变量属性框了 尤其是配合历史记录的情况下，如果你上一次打开的是cmd，这次你不输入任何值默认就会显示cmd，以及如果发现这个功能没了请去设置内开启下列图片中的开关，即可使用这个功能了 一定的写入方法 一般cmd环境下，如果你想把一部分内容直接输入到某个文件上，可以通过以下命令实现\ncommand_output \u0026gt; 1.txt\n例如下面这个命令\ndir *spacesniffer* /s/b \u0026gt;1.txt\n下面是原本的输出的内容，但是一旦加上了\u0026gt;1.txt后，所有的输出都被截断，命令行不显示输出，取而代之把输出写入了当前工作目录的1.txt文件中，注意，这个文件也可以不存在，这一行命令会自动新建1.txt文件\nE:\\软件\u0026gt;dir *spacesniffer* /s/b E:\\软件\\spacesniffer_1_3_0_2 E:\\软件\\spacesniffer_1_3_0_2\\SpaceSniffer.exe E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2 E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2.zip E:\\软件\\文件索引、扫描工具\\spacesniffer_1_3_0_2\\SpaceSniffer.exe E:\\软件\\资源类软件\\spacesniffer_1_3_0_2.zip 其他用途 在我的手里，一般cmd是一个默认的启动器吧，比如如果不希望启动pycharm这么个庞然大物去运行某个python脚本的话，一般可以通过\n@echo off python python-script.py 这样的方法去启动某个脚本，也省去了你敲命令的时间，比如隔壁git教程那一侧git教程 但记住一点，尽量用ANSI格式去保存代码文件,全英文状态下可能只能是默认的utf-8，编解码参考视频 @echo off cd .. cd personal-blog hugo git add . set \u0026#34;year=%date:~0,4%\u0026#34; set \u0026#34;month=%date:~5,2%\u0026#34; set \u0026#34;day=%date:~8,2%\u0026#34; set \u0026#34;formatted_date=%year%-%month%-%day%\u0026#34; git commit -m \u0026#34;Upload file in %formatted_date%\u0026#34; git push -u origin main pause 其中@echo off为关闭回显状态，也就是不显示E:\\personal-blog\\personal-blog\u0026gt;这个以及命令本身，但不会关闭这个命令本身的输出，pause会使得命令不会跑完就命令窗口消失\n一些杂谈 一般bat脚本被用来直接用for循环的还是少，一般会被用来作一些简单的启动，比如启动python执行某个脚本什么的，这种比较方便，虽然有for循环 但对比其他语言来说，实在有点眼花缭乱，一般用AI去问问就差不多了，我不喜欢在cmd命令里用for循环，在里面定义读取个变量很多时候也够呛， 但也不否认，如果用它写一些简单的东西，可以省去很多的重复劳动，做到一定的自动化，这一点我还是比较喜欢的\ncurl curl \u0026ndash;proxy 127.0.0.1:4780 www.google.com\nkimi给了错误的x参数，然后报错了，被AI气晕.jpg，先贴在这吧，以及是，powershell环境运行有可能会导致未知报错，可能需要切换cmd环境\n","date":"2025-02-04T22:34:00+08:00","image":"https://adeepblue.github.io/p/cmd%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/CommandLineIcon_hu_92fdb1cf55bf8472.png","permalink":"https://adeepblue.github.io/p/cmd%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/","title":"Cmd命令介绍"},{"content":"Hugo笔记 首先是先下载hugo,我的话因为后面可能命令行会比较常用，所以手动把它添加进了环境变量 path里面 也是有这个步骤才可以下面直接hugo命令直接用了\n前前后后也搞了不少时间，万一以后文件丢失了可以来这边参考我自己写的hugo笔记\n建站 新建站点 命令如下\nhugo new site personal-blog\n此处personal-blog可替换文件夹名字，会自动新建文件夹然后在该文件夹下放初始化的内容\n新建页面 新建完网站本身之后就可以开始写md文件了，比如此处我新建了hugo/hugo-init.md文件，命令如下\nhugo new hugo/hugo-init.md\n命令行返回为\nE:\\personal-blog\\personal-blog\u0026gt;hugo new git/git-init.md Content \u0026#34;E:\\\\personal-blog\\\\personal-blog\\\\content\\\\git\\\\git-init.md\u0026#34; created 但一般推荐写文章在./content/post/foldername/index.md下，其中用文件夹名用标识内容方便自己后续区分，比如说例如这篇文章就在./content/post/hugo/index.md下，因为默认hugo识别文章一般 会去./content/post/文件夹下找md文件，例如我的文件结构如下\n├─categories │ └─Test ├─page │ ├─about │ └─search └─post ├─cmd ├─git ├─hugo ├─python-matplotlib ├─test └─turing-complete 其他page和categories文件夹我没去管，等到文章写多了才会利用那些整一整\nmd文件头和文件内容 再有就是自带的文件头，\n+++ date = \u0026#39;2025-02-04T21:10:15+08:00\u0026#39; draft = false title = \u0026#39;Test\u0026#39; +++ 原本draft中的值是true,需要改成false才能进行页面发布 ，可能是因为类似审核的过程？方便管理确认？亦或者说不想显示 某篇文章先用这种方式隐藏起来？虽然也只是我的猜测而已罢了\n# 文章标题 这是你的主要内容部分。你可以在这里添加文本、列表、引用、图像等。 ## 子标题 ### 列表示例 - 第一项 - 第二项 - 第三项 ### 引用示例 \u0026gt; 这是一个引用的例子。 ### 图片示例 ![图片描述](图片链接) ### 代码示例 `ssh git@github.com` 一般文件结构介绍 以及是，content目录下必须包含_index.md文件，不然会不显 示主页，这就是主页， 命令可以以下方法实现\nhugo new _index.md 但一般如果是用的第三方主题可以把exampleSite文件夹中的content和hugo.yaml文件拉出来，其中的content文件夹就包含了_index.md，这样也就不用自己写了 除非是要自己构建主题，那就得自己新建_index.md布局文件\n然后我目前打算添加的代码，虽然已经弃用（用第三方主题了）\n--- menu: main: name: 主页 weight: -100 params: icon: home --- 曾遇到的问题 目前git处文章不显示，未知原因，起初发现draft=true没修改，但目前不清楚因为什么导致不显示\n总觉得hugo挺多bug的，之前有404过不少时间，调试了很久重新开始hugo new site personal-blog 然后重建git仓库，弄了许久没弄好，现在又出现hugo new post/cmd/index.md没法创建 疑似可能是因为hugo server正在启动无法使用new命令吧\n写的文markdown文件如果不是index.md的话会出现头字段(front matter)image字段图片加载失败的问题\n修改背景图片 也奇怪，一开始没搞定背景图片，这次一遍过了，下面这条命令是创建文件夹的命令，在网站根目录打开cmd运行\nmd .\\assets\\background\n然后在这个文件夹内放背景图片后，运行以下命令创建\nmd .\\layouts\\partials\\footer touch .\\layouts\\partials\\footer\\custom.html 并将以下代码直接放入上面新建的custom.html内部\n\u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 此处感谢莱特雷-letere大佬的博客指引网页链接\n代码高亮 呃啊，折腾了一两天的代码高亮，我以为被原始的样式覆盖了，折腾了很久都没搞好，结果一删AI生成的代码立马好了，我无法接受啊啊啊啊\n不推荐用 npm install highlight.js的方式安装，我安装完少了highlight.min.js文件\nhighlight.min.js放在./assets/js/目录下， styles文件夹复制出来改文件名成highlight-styles后放在/assets/css/目录下，如下 虽然我也没搞懂是什么个情况就稀里糊涂的搞好了，其中hugo.yaml中的配置如下\nhighlight: noClasses: false codeFences: true guessSyntax: true lineNoStart: 1 lineNos: false lineNumbersInTable: false tabWidth: 4 style: monokai # noHl: true 至此，莫名其妙的搞定了，本人也是hugo新手，其他人博客的很简便写的东西没怎么看懂，奈何html水平不够，写这些在这方便参考\n加入图片 ![图片说明](图片链接) 也可以直接插入HTML片段，比如直接在markdown环境下输入这个调整图片的大小，markdown的另一种调整方式疑似在stack主题下或者说hugo环境下不可用，不过我并没有做过测试就是\n{\\{\u003c figure src=\"picture.png\" width=\"400px\" height= \"340px\" title=\"title\" align=\"left\" \u003e\\}\\} 不过最后的align参数貌似没什么用就是了，是从网上看来的\n下面是hugo环境下不可用的写法,至少我目前测试是不可用的\n![图片说明](picture.jpg?fit=200x100) 标记文字 标记方法如下 \u0026lt;span style=\u0026quot;color:blue\u0026quot;\u0026gt;标记方法如下\u0026lt;/span\u0026gt;这样标蓝就行\n也可以插入div表示一个块 居中且标红的 HTML。 其中上面的代码如下 \u0026lt;div class=\u0026#34;myclass text-danger\u0026#34; style=\u0026#34;text-align:center;color :red;\u0026#34;\u0026gt; 居中且标红的 \u0026lt;u\u0026gt;HTML\u0026lt;/u\u0026gt;。 \u0026lt;/div\u0026gt; 图表绘制 x 1 2 3 4 5 6 7 y 1 0 -1 -2 -3 -4 -3 x 1 2 3 4 5 6 7 x 1 2 3 4 5 6 8 这样的图表应该怎么绘制呢？看以下源代码，其中第二行得标识对齐，其中-这个符号即是表示这一列的长度最长的显示位数 不得多于对应的长度，比如说如果只有一个-，就不能输入-1了，要表示-1必须在第二行对齐处多加一个-,也就是\u0026ndash; 其中单左冒号表示左对齐，单右冒号表示右对齐，两边都有则是居中，一般markdown中输入会跟随你的最长的数字，已经组好表格的 情况下，你如果在这一位插入数字会自动帮你添加-，但删到数字没有了记得补上-,因为你把文本删光了对应上面也就没有-了， 需要手动去调整 | x | 1 | 2 | 3 | 4 | 5 | 6 | 7 | |:-:|:-:|:-:|:--:|:--:|:--:|:--:|:--:| | y | 1 | 0 | -1 | -2 | -3 | -4 | -3 | | | | | | | | | | | x | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | x | 1 | 2 | 3 | 4 | 5 | 6 | 8 | x 1 2 3 4 5 6 7 y 1 0 -1 -2 -3 -4 -3 x 1 2 3 4 5 6 7 x 1 2 3 4 5 6 8 链接css样式表进页面 因为我当时要改左侧样式表的页面，因为完全没有颜色会让左侧标签栏变得看不到，如下，我选择了加入伪元素达到类似蒙版的效果 因为deepseek给出的文件放置位置错误，当时它提示我放在./assets/css/custom.css中调用，调用的时候只需要调用/css/custom.css就行了， 结果没生效，到头来是在./static/css/custom目录下调用成了,参考了网页链接这篇文章 企图修改边栏文字 修改内容如下\n./content/pages/archives/index.md # title 字段和slug字段，分别改成中文 ./content/pages/search/index.md # 同上 以及hugo.yaml文件中\nhomepage: - type: search - type: archives 以及文件夹部分\n./content/pages/search/改为./content/pages/搜索/ ./content/pages/archives/改为./content/pages/归档/ 结果：改完可以生效左侧文字，但是右侧工具栏失效\n删除多语言选项框 配置一下hugo.yaml文件就行 以下\nlanguages: zh-cn: languageName: 中文 title: 深蓝之亘的博客 weight: 2 params: sidebar: subtitle: 欢迎来到我的博客网站 上述位置删掉en键值就行，只保留一个zh-cn，或者保留en但需要去调模板的值\n数学公式的渲染 一直没动手，因为稍微有点懒，这回几乎是有硬需求了才更新这块，在/layouts/partials/head/head.html中加入以下内容\n\u0026lt;!-- KaTeX --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body); }); \u0026lt;/script\u0026gt; 参考了网页链接\n下标，如果只是一个数$a_0$可以直接化成$a_0$,但如果多个数就得$a_{a+b}$,这样可以化成$a_{a+b}$,分数的使用则是$\\frac {1} {2}$\n$$\\frac {1} {2}$$还有，切记，在代码段前如果放文字会被吞，比如\n123 $$ \\frac {1}{2} $$ 其中这个123会不显示\n矩阵的输入，虽然这个实例中表示的不是矩阵，是除法\n$$ \\begin{array}{r|r} \u0026amp; \\text{29} \\\\ \\hline \\text{25}\u0026amp; \\text{732} \\\\ \\hline \u0026amp; \\vdots \\\\ \u0026amp; \\text{余数} \\end{array} $$ 目前用到的一些符号 $\\cdot$ -\u0026gt; $\\cdot$, $\\div$-\u0026gt; $\\div$ \\overline{A} -\u0026gt;$\\overline{A}$\n","date":"2025-02-04T22:34:00+08:00","image":"https://adeepblue.github.io/p/hugo%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/Logo_of_Hugo_the_static_website_generator.svg_hu_4d8ab91ad958cac5.png","permalink":"https://adeepblue.github.io/p/hugo%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BD%91%E7%AB%99%E7%AC%94%E8%AE%B0/","title":"Hugo初始化网站笔记"},{"content":"Git连接踩坑记录 配置SSH 重装电脑之后（并不重装D盘），git又连不上GitHub了，也不知道是出了什么毛病， 昨晚连接SSH都连不上，我只依稀记得以前踩了许多坑，再回过头来 捣鼓又是估计好一番功夫了，所以在这写下这篇文章为以后的我参考，方便以后快速配置 ssh -T git@github.com\nssh -vT git@github.com (加了v之后会输出调试信息)\n也疯狂报错 报错信息如下\n$ ssh -T adeepblue@github.com /usr/bin/bash: line 1: exec: nc: not found Connection closed by UNKNOWN port 65535 报错查找 但我依稀记得我当时折腾ssh和GitHub的时候没用nc代理工具，这回莫名奇妙有这个报错了 曾经的目录长这样\nC:\\Users\\Deepblue\\.ssh\u0026gt;dir /b authorized_keys id_ed25519 id_ed25519.pub id_rsa.pub id_rsa_2048 known_hosts testpub config 最后对比曾经重装电脑留下的备份文件发现多了一个config，然后点进去发现这玩意居然 显示要nc的配置什么的，幡然醒悟，哦，ssh出问题原来就是你这个文件捣的鬼，\n文件内容如下:\nHost github.com User git ProxyCommand nc -v -x 127.0.0.1:4780 %h %p 如果我当初没有备份目录我可能都没意识到，一删 除这个文件之后ssh -T git@github.com立马可以通了，也是给我整无语了\n初始化仓库 仓库的配置，先需要初始化仓库 HTTPS协议的通道的演示：\ngit init REM 新建并切到主分支（此处为cmd的备注方式） git checkout -b main REM 添加所有文件到git暂存区 git add . REM 提交到分支 git commit -m \u0026#34;提交信息,比如init\u0026#34; REM 配置代理，以我电脑上目前的科学上网工具为例，本地环路端口号为4780 git config --global http.proxy http://127.0.0.1:4780 git config --global https.proxy https://127.0.0.1:4780 REM git 添加你的仓库，此处不带git，因为我使用了SSH配置，所以也使用SSH的方式 REM 推送另一种方式我没用所以此处不写 REM 初次添加使用add，如果是一不小心输入错误需要修改就用第二条命令 set-url参数的 git remote add origin https://github.com/Adeepblue/adeepblue.github.io git remote set-url origin https://github.com/Adeepblue/adeepblue.github.io REM 推送，如果本地分支跟远程分支不同可使用-f参数强制推送 git push -f origin main / git push origin main --force REM 列出所有配置 git config --list REM 删除配置 git config --global --unset http.https://github.com.proxy 以上，调试完毕\n如果走SSH协议的话，上面add origin或者是set-url origin后面的命令得修改成 git@github.com:Adeepblue/adeepblue.github.io，其中要确保SSH已经验证过了，\ngit add -f public git commit -m \u0026#34;Publish site\u0026#34; git subtree push --prefix public origin gh-pages 以及，现在的hugo推送，这样就可以推送到gh-pages分区进行展示了，需要GitHub修改一下仓库设置\n仓库迁移 最近自动化上传的时候遇到了这么个提示，也就是上面配置这边原始的命令那，git得补上了，我也不知道为什么，至少它现在提示了\nremote: This repository moved. Please use the new location: remote: git@github.com:ADeepblue/adeepblue.github.io.git 然后我现在就用一行命令移动过去了\ngit remote set-url origin git@github.com:ADeepblue/adeepblue.github.io.git .gitignore文件 直接写入需要忽视的文件即可，可以让git add . 时跳过这些文件以回车分隔即可\n自动化部署 我给一个我目前在用的自动化部署方案吧，我现在的仓库根目录是E:\\personal-blog\\personal-blog,我配置了我的自动化目录在E:\\personal-blog\\automatical-test 这里并不是git仓库的一部分，所以这个文件并不会上传，但是我分享在这里吧，仅作为参考，如果需要解析请移步隔壁cmd教程cmd命令介绍\nREM E:\\personal-blog\\automatical-test\\推送主分支.bat @echo cd .. cd personal-blog hugo git add . set \u0026#34;year=%date:~0,4%\u0026#34; set \u0026#34;month=%date:~5,2%\u0026#34; set \u0026#34;day=%date:~8,2%\u0026#34; set \u0026#34;formatted_date=%year%-%month%-%day%\u0026#34; git commit -m \u0026#34;Upload file in %formatted_date%\u0026#34; git push -u origin main pause REM E:\\personal-blog\\automatical-test\\发布文章.bat @echo off setlocal rem 从 %date% 按位置提取年月日（假设格式固定为 YYYY/MM/DD） set \u0026#34;year=%date:~0,4%\u0026#34; set \u0026#34;month=%date:~5,2%\u0026#34; set \u0026#34;day=%date:~8,2%\u0026#34; set \u0026#34;formatted_date=%year%-%month%-%day%\u0026#34; cd .. cd personal-blog git add -f public git commit -m \u0026#34;Publish site %formatted_date%\u0026#34; git subtree push --prefix public origin gh-pages pause 免责声明 脚本仅供学习参考：本文中分享的自动化脚本仅供个人学习和参考使用，不保证适用于所有环境或符合所有公司的规范和要求。 使用风险自负：在使用本文中的脚本时，请确保您已充分了解其功能和潜在风险。如果您在公司环境中使用该脚本，请务必根据公司的相关规定和要求进行修改和调整。因使用该脚本导致的任何问题或损失，作者概不负责。 遵守公司规定：如果您在公司环境中使用该脚本，请务必遵守公司的相关规定和要求。例如，提交信息的格式、仓库的命名规范等。因未遵守公司规定而导致的任何问题或纠纷，作者概不负责。 自行测试和验证：在将该脚本应用于实际工作环境之前，请务必在测试环境中进行充分的测试和验证，以确保其符合您的需求和环境要求。 ","date":"2025-02-04T21:39:19+08:00","image":"https://adeepblue.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%B0%E5%BD%95/git-bash.svg","permalink":"https://adeepblue.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%B0%E5%BD%95/","title":"Git初始化记录"}]